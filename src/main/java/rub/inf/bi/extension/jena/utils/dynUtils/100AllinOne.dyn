{
  "Uuid": "8b1e7f7f-7304-4d5e-a570-fd8ce7ff620e",
  "IsCustomNode": false,
  "Description": null,
  "Name": "100AllinOne",
  "ElementResolver": {
    "ResolutionMap": {}
  },
  "Inputs": [],
  "Outputs": [],
  "Nodes": [
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "NodeType": "PythonScriptNode",
      "Code": "# Load the Python Standard and DesignScript Libraries\r\nimport sys\r\nimport clr\r\nimport json\r\nimport os\r\nimport random\r\nimport pickle\r\nimport io\r\nimport ctypes\r\nimport xml.etree.ElementTree as ET\r\nsys.path.append(r\"C:\\Users\\yhe\\AppData\\Local\\Programs\\Python\\Python310\\Lib\\site-packages\")\r\nfrom xml.dom.minidom import parse, parseString\r\n\r\nclr.AddReference('ProtoGeometry')\r\nfrom Autodesk.DesignScript.Geometry import *\r\nclr.AddReference('DSCoreNodes')\r\nfrom DSCore import *\r\nclr.AddReference('GeometryColor')\r\nfrom Modifiers import GeometryColor\r\nclr.AddReference('MeshToolkit')\r\nfrom Autodesk.Dynamo.MeshToolkit import *\r\n\r\n############## Random Geometry Generator ###############\r\n\r\ndef random_geo_generator(factor):\r\n    NUM_POINT = 0\r\n    NUM_MULTIPOLYGON = 10 + factor*2\r\n    NUM_POLYGON = 10 + factor*3\r\n    NUM_LINESTRING = 10 + factor*4\r\n    NUM_POINT = 10\r\n    NUM_SPHERE = 0\r\n    \r\n    POINT = \"POINT\";\r\n    MULTIPOINT = \"MULTIPOINT\";\r\n    LINESTRING = \"LINESTRING\";\r\n    MULTILINESTRING = \"MULTILINESTRING\";\r\n    POLYGON = \"POLYGON\";\r\n    POLYGON_ROTATION = \"POLYGON_ROTATION\"\r\n    MULTIPOLYGON = \"MULTIPOLYGON\"\r\n    MULTIPOLYGON_ROTATION = \"MULTIPOLYGON_ROTATION\"\r\n    SPHERE = \"MULTIPOLYGON_SPHERE\"\r\n    GEOMETRYCOLLECTION = \"GEOMETRYCOLLECTION\";\r\n    # output container\r\n    geo_lst = []\r\n    \r\n    geo_pt_lst = []\r\n    geo_li_lst = []\r\n    geo_pol_lst = []\r\n    geo_mPol_lst = []\r\n    geo_sph_lst = []\r\n    \r\n    geo_combi_lst = []\r\n    \r\n    ################### Polygon #######################\r\n    # random triangle(s)\r\n    for ind_pol in range(0, NUM_POLYGON):\r\n        pt_lst = []\r\n        \r\n        x_axis_lst = random.sample(range(-10, 10, 2), 3)\r\n        y_axis_lst = random.sample(range(-10, 10, 2), 3)\r\n        z_axis_lst = random.sample(range(-10, 10, 2), 3)\r\n        \r\n        offset_lst = random.sample(range(-50, 50, 2), 3)\r\n        \r\n        pt_lst = [Point.ByCoordinates(x_axis_lst[0] + offset_lst[0], y_axis_lst[0] + offset_lst[1], z_axis_lst[0] + offset_lst[2]),\r\n                  Point.ByCoordinates(x_axis_lst[1] + offset_lst[0], y_axis_lst[1] + offset_lst[1], z_axis_lst[1] + offset_lst[2]), \r\n                  Point.ByCoordinates(x_axis_lst[2] + offset_lst[0], y_axis_lst[2] + offset_lst[1], z_axis_lst[2] + offset_lst[2])]\r\n    \r\n        geo_data = pt_lst\r\n        geo_name = POLYGON + str(ind_pol+1)\r\n        geo_type = POLYGON\r\n        geometry = Surface.ByPerimeterPoints(pt_lst)\r\n    \r\n        geo_obj_pol = (geo_data, geo_name, geo_type, geometry)\r\n        \r\n        geo_pol_lst.append(geo_obj_pol)\r\n    \r\n    ###################### Multi-Polygon ##########################\r\n    # random cube(s)\r\n    for ind_mul_pol in range(0, NUM_MULTIPOLYGON):\r\n        \"\"\"\r\n        corner pt 1 : (x, y, z)\r\n        corner pt 2 : (x+l, y+l, z+l)\r\n        \"\"\"\r\n        pt_lst = []\r\n        is_rotated = random.randint(0,1)\r\n        x_axis = random.randint(-10, 10)\r\n        y_axis = random.randint(-10, 10)\r\n        z_axis = random.randint(-10, 10)\r\n        l = random.randint(1, 8)\r\n        \r\n        offset_lst = random.sample(range(-50, 50, 2), 3)\r\n        p1 = Point.ByCoordinates(x_axis + offset_lst[0], \r\n                                 y_axis + offset_lst[1], \r\n                                 z_axis + offset_lst[2])\r\n                                 \r\n        p2 = Point.ByCoordinates(x_axis + l + offset_lst[0], \r\n                                 y_axis + l + offset_lst[1], \r\n                                 z_axis + l + offset_lst[2])\r\n        \r\n        geometry = Cuboid.ByCorners(p1, p2)\r\n        geo_data = geometry\r\n        geo_name = MULTIPOLYGON + str(ind_mul_pol+1)\r\n        geo_type = MULTIPOLYGON\r\n        \r\n        if is_rotated == 0:\r\n            old_cs = CoordinateSystem.Identity()\r\n            new_cs = CoordinateSystem.Identity()\r\n            new_cs2 = new_cs.Rotate(Point.ByCoordinates(random.randint(-10, 10), random.randint(-10, 10), random.randint(-10, 10)),\r\n                                    Vector.ByCoordinates(random.randint(-10, 10), random.randint(-10, 10), random.randint(-10, 10)), \r\n                                    random.randint(0, 360))\r\n            geometry = geometry.Transform(old_cs, new_cs2)\r\n            \r\n            geo_data = geometry.Faces\r\n            geo_name = MULTIPOLYGON + str(i+1)\r\n            geo_type = MULTIPOLYGON_ROTATION\r\n        \r\n        geo_obj_mPol = (geo_data, geo_name, geo_type, geometry)\r\n        geo_mPol_lst.append(geo_obj_mPol)\r\n    \r\n    ###################### LineString ###########################\r\n    \r\n    # random LineString(s)\r\n    pt_lst= []\r\n    for ind_line in range(0, NUM_LINESTRING): # random number of line strings\r\n    \r\n        rand_length = random.randint(1,3) # random length of line strings\r\n        for j in range(0, rand_length):\r\n            x_axis = random.randint(-50, 50)\r\n            y_axis = random.randint(-50, 50)\r\n            z_axis = random.randint(-50, 50)\r\n            l = random.randint(1, 2)\r\n            offset_lst = random.sample(range(-20, 20, 2), 3)\r\n            \r\n            pt_s = Point.ByCoordinates(x_axis + offset_lst[0], \r\n                                     y_axis + offset_lst[1], \r\n                                     z_axis + offset_lst[2])\r\n            pt_e = Point.ByCoordinates(x_axis + l + offset_lst[0], \r\n                                     y_axis + l + offset_lst[1], \r\n                                     z_axis + l + offset_lst[2])\r\n            pt_lst.append(pt_s)\r\n            pt_lst.append(pt_e)\r\n    \r\n    geo_data = pt_lst\r\n    geo_name = LINESTRING + str(ind_line+1)\r\n    geo_type = LINESTRING\r\n    geometry = PolyCurve.ByPoints(pt_lst, False)\r\n    geo_obj_li = (geo_data, geo_name, geo_type, geometry)\r\n    geo_li_lst.append(geo_obj_li)\r\n    \r\n    #################### Case Study #############################\r\n    \r\n    # (Multi)polygon <==> (Multi)polygon (incl. rotation)\r\n    case_mp_mp = []\r\n    \r\n    # (Multi)polygon <==> LingString (incl. rotation)\r\n    case_mp_ls = []\r\n    \r\n    # (Multi)polygon <==> Sphere (incl. rotation)\r\n    case_mp_sp = []\r\n    \r\n    # Sphere <==> LingString\r\n    case_sp_ls = []\r\n    \r\n    geo_combi_lst = geo_pt_lst + geo_li_lst + geo_pol_lst + geo_mPol_lst + geo_sph_lst\r\n    return geo_combi_lst\r\n\r\n#################### WKT Converter #############################\r\ndef lineString2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name):\r\n    wktLiteral = \"<sf:LineString>\";\r\n    wktLiteral += \"<rdf:Description rdf:about='\" + exampleInstanceNamespace + str(name) + \"'>\";\r\n    wktLiteral += \"<geo:asWKT rdf:datatype='\" + geoSparqlNamespace + \"wktLiteral'>\";\r\n    wktLiteral += \"LINESTRING Z((\";\r\n    \r\n    points =  geo_data\r\n    originP = points[0];\r\n    \r\n    wktLiteral += str(originP.X) + \" \" +  str(originP.Y) + \" \" +  str(originP.Z) # start point\r\n    for i in range(1, len(points)):\r\n        wktLiteral += \", \" + str(points[i].X) + \" \" +  str(points[i].Y) + \" \" +  str(points[i].Z);       \r\n    #wktLiteral += \", \" + str(originP.X) + \" \" +  str(originP.Y) + \" \" +  str(originP.Z); # end point\r\n    wktLiteral += \"))\"\r\n    \r\n    wktLiteral += \"</geo:asWKT>\";\r\n    wktLiteral += \"</rdf:Description>\";\r\n    wktLiteral += \"</sf:LineString>\";\r\n    return wktLiteral\r\n\r\ndef sphere2WKT(surface_lst, exampleInstanceNamespace, geoSparqlNamespace, name):\r\n    wktLiteral = \"<sf:MultiPolygon>\";\r\n    wktLiteral += \"<rdf:Description rdf:about='\" + exampleInstanceNamespace + str(name) + \"'>\";\r\n    wktLiteral += \"<geo:asWKT rdf:datatype='\" + geoSparqlNamespace + \"wktLiteral'>\";\r\n    \r\n    # for curves/surfaces\r\n    face_wkt_lst = \"\"\r\n    for vert_lst in surface_lst:\r\n        \r\n        vert_wkt_lst = \"((\"\r\n        for vert in vert_lst:\r\n        \r\n            vert_wkt_lst += str(vert.X) + \" \" +  str(vert.Y) + \" \" +  str(vert.Z);\r\n            if vert != vert_lst[-1]:\r\n                vert_wkt_lst += \", \"\r\n        \r\n        vert_wkt_lst += \", \" + str(vert_lst[0].X) + \" \" +  str(vert_lst[0].Y) + \" \" +  str(vert_lst[0].Z) + \"))\";\r\n        \r\n        face_wkt_lst += vert_wkt_lst\r\n        if vert_lst != surface_lst[-1]:\r\n            face_wkt_lst += \", \"          \r\n            \r\n    wktLiteral += \"MULTIPOLYGON Z(\";\r\n    wktLiteral += face_wkt_lst\r\n    wktLiteral += \")\"\r\n    wktLiteral += \"</geo:asWKT>\";\r\n    wktLiteral += \"</rdf:Description>\";\r\n    wktLiteral += \"</sf:MultiPolygon>\";\r\n    return wktLiteral\r\n    \r\n    \r\ndef multipolygonInRotation2WKT(face_lst, exampleInstanceNamespace, geoSparqlNamespace, name):\r\n    wktLiteral = \"<sf:MultiPolygon>\";\r\n    wktLiteral += \"<rdf:Description rdf:about='\" + exampleInstanceNamespace + str(name) + \"'>\";\r\n    wktLiteral += \"<geo:asWKT rdf:datatype='\" + geoSparqlNamespace + \"wktLiteral'>\";\r\n    face_wkt_lst = \"\"\r\n    \r\n    for face in face_lst:\r\n        \r\n        vertice_lst = face.Vertices\r\n        org_vert_pt = vertice_lst[0].PointGeometry \r\n        face_wkt = \"((\" + str(org_vert_pt.X) + \" \" +  str(org_vert_pt.Y) + \" \" +  str(org_vert_pt.Z) # start point\r\n    \r\n        for i in range(1, len(vertice_lst)):\r\n            vert_pt = vertice_lst[i].PointGeometry\r\n            face_wkt += \", \" + str(vert_pt.X) + \" \" +  str(vert_pt.Y) + \" \" +  str(vert_pt.Z)       \r\n        face_wkt += \", \" + str(org_vert_pt.X) + \" \" +  str(org_vert_pt.Y) + \" \" +  str(org_vert_pt.Z) + \"))\" # end point\r\n        \r\n        if(face != face_lst[-1]):\r\n            face_wkt += \", \"\r\n        face_wkt_lst += face_wkt        \r\n    \r\n    wktLiteral += \"MULTIPOLYGON Z(\"\r\n    wktLiteral += face_wkt_lst\r\n    wktLiteral += \")\" \r\n    wktLiteral += \"</geo:asWKT>\"\r\n    wktLiteral += \"</rdf:Description>\"\r\n    wktLiteral += \"</sf:MultiPolygon>\"\r\n    return wktLiteral\r\n    \r\n    \r\ndef multipolygon2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name):\r\n    wktLiteral = \"<sf:MultiPolygon>\";\r\n    wktLiteral += \"<rdf:Description rdf:about='\" + exampleInstanceNamespace + str(name) + \"'>\";\r\n    wktLiteral += \"<geo:asWKT rdf:datatype='\" + geoSparqlNamespace + \"wktLiteral'>\";\r\n    \r\n    # for cuboids with geometry = [centroid, length]\r\n    centroid = Solid.Centroid(geo_data)\r\n    offset = geo_data.Length/2\r\n    c_X = centroid.X\r\n    c_Y = centroid.Y\r\n    c_Z = centroid.Z\r\n\r\n    # idea: determine the coordinates of bottom- and top faces\r\n    \r\n    # p1 -- p2\r\n    # |  c   |\r\n    # p3 -- p4           \r\n    # bottom-face\r\n    bottom_p1 = str(c_X-offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z-offset)\r\n    bottom_p2 = str(c_X-offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z-offset) \r\n    bottom_p3 = str(c_X+offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z-offset)\r\n    bottom_p4 = str(c_X+offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z-offset)\r\n    bottom_face = \"((\" + bottom_p1 + \", \" + bottom_p2 + \", \" + bottom_p3 + \", \" + bottom_p4 +  \", \" + bottom_p1 + \"))\"\r\n    # top-face\r\n    top_p1 = str(c_X-offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z+offset)\r\n    top_p2 = str(c_X-offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z+offset) \r\n    top_p3 = str(c_X+offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z+offset)\r\n    top_p4 = str(c_X+offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z+offset)\r\n    top_face = \"((\" + top_p1 + \", \" + top_p2 + \", \" + top_p3 + \", \" + top_p4 +  \", \" + top_p1 + \"))\"\r\n    # front-face\r\n    front_p1 = str(c_X-offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z-offset)\r\n    front_p2 = str(c_X-offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z-offset) \r\n    front_p3 = str(c_X-offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z+offset) \r\n    front_p4 = str(c_X-offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z+offset)\r\n    front_face = \"((\" + front_p1 + \", \" + front_p2 + \", \" + front_p3 + \", \" + front_p4 + \", \" + front_p1 + \"))\"\r\n    # back-face             \r\n    back_p1 = str(c_X+offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z-offset)\r\n    back_p2 = str(c_X+offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z-offset) \r\n    back_p3 = str(c_X+offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z+offset) \r\n    back_p4 = str(c_X+offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z+offset)\r\n    back_face = \"((\" + back_p1 + \", \" + back_p2 + \", \" + back_p3 + \", \" + back_p4 + \", \" + back_p1 + \"))\"\r\n    # left-face\r\n    left_p1 = str(c_X-offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z-offset)\r\n    left_p2 = str(c_X+offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z-offset)\r\n    left_p3 = str(c_X+offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z+offset)\r\n    left_p4 = str(c_X-offset) + \" \" + str(c_Y-offset) + \" \" + str(c_Z+offset)\r\n    left_face = \"((\" + left_p1 + \", \" + left_p2 + \", \" + left_p3 + \", \" + left_p4 + \", \" + left_p1 + \"))\"            \r\n    # right-face\r\n    right_p1 = str(c_X-offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z-offset)\r\n    right_p2 = str(c_X+offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z-offset)\r\n    right_p3 = str(c_X+offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z+offset)\r\n    right_p4 = str(c_X-offset) + \" \" + str(c_Y+offset) + \" \" + str(c_Z+offset)\r\n    right_face = \"((\" + right_p1 + \", \" + right_p2 + \", \" + right_p3 + \", \" + right_p4 + \", \" + right_p1 + \"))\"\r\n    \r\n    cuboid_face = bottom_face + \", \" + top_face + \", \" + front_face + \", \" + back_face + \", \" + left_face + \", \" + right_face\r\n    \r\n    wktLiteral += \"MULTIPOLYGON Z(\"\r\n    try:\r\n        wktLiteral += cuboid_face\r\n    except e:\r\n        return e\r\n    print(cuboid_face)\r\n    wktLiteral += \")\"\r\n    wktLiteral += \"</geo:asWKT>\"\r\n    wktLiteral += \"</rdf:Description>\"\r\n    wktLiteral += \"</sf:MultiPolygon>\"\r\n    return wktLiteral\r\n    \r\n    \r\ndef polygon2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name):\r\n    wktLiteral = \"<sf:POLYGON>\";\r\n    wktLiteral += \"<rdf:Description rdf:about='\" + exampleInstanceNamespace + str(name) + \"'>\";\r\n    wktLiteral += \"<geo:asWKT rdf:datatype='\" + geoSparqlNamespace + \"wktLiteral'>\";\r\n    wktLiteral += \"POLYGON Z((\";\r\n    \r\n    points =  geo_data\r\n    originP = points[0];\r\n    \r\n    wktLiteral += str(originP.X) + \" \" +  str(originP.Y) + \" \" +  str(originP.Z) # start point\r\n    for i in range(1, len(points)):\r\n        wktLiteral += \", \" + str(points[i].X) + \" \" +  str(points[i].Y) + \" \" +  str(points[i].Z);       \r\n    wktLiteral += \", \" + str(originP.X) + \" \" +  str(originP.Y) + \" \" +  str(originP.Z); # end point\r\n    wktLiteral += \"))\"\r\n    \r\n    wktLiteral += \"</geo:asWKT>\";\r\n    wktLiteral += \"</rdf:Description>\";\r\n    wktLiteral += \"</sf:POLYGON>\";\r\n    return wktLiteral\r\n\r\n#####\r\ndef wkt_Converter(geometry_lst):\r\n# The inputs to this node will be stored as a list in the IN variables.\r\n    geo_lst = geometry_lst\r\n    geoSparqlNamespace = \"http://www.opengis.net/ont/geosparql#\"\r\n    exampleInstanceNamespace = \"https://www.inf.bi.ruhr-uni-bochum.de/jena/#\"\r\n    \r\n    res = []\r\n    for geo_obj in geo_lst:\r\n        geo_data = geo_obj[0];\r\n        name = geo_obj[1];\r\n        geometryType = geo_obj[2];\r\n        \r\n        if(geometryType.upper() == \"MULTIPOLYGON_ROTATION\"):\r\n            res.append(multipolygonInRotation2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name))\r\n            continue\r\n        \r\n        if(geometryType.upper() == \"MULTIPOLYGON_SPHERE\"):\r\n            res.append(sphere2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name))    \r\n            continue\r\n         \r\n        if(geometryType.upper() == \"MULTIPOLYGON\"):\r\n            res.append(multipolygon2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name))\r\n            continue\r\n            \r\n        if(geometryType.upper() == \"POLYGON_ROTATION\"):\r\n            res.append(polygon2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name))\r\n            continue\r\n            \r\n        if(geometryType.upper() == \"POLYGON\"):\r\n            res.append(polygon2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name))\r\n            continue\r\n            \r\n        if(geometryType.upper() == \"LINESTRING\"):\r\n            res.append(lineString2WKT(geo_data, exampleInstanceNamespace, geoSparqlNamespace, name))\r\n            continue\r\n    return res\r\n\r\n############## RDF Wrapper ###############\r\ndef RDF_Wrapper(WKT_res):\r\n    rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\r\n    owl=\"http://www.w3.org/2002/07/owl#\";\r\n    ogc=\"http://www.opengis.net/\";\r\n    my=\"https://www.inf.bi.ruhr-uni-bochum.de/jena/#\";\r\n    gml=\"http://www.opengis.net/ont/gml#\";\r\n    geo=\"http://www.opengis.net/ont/geosparql#\";\r\n    geof=\"http://www.opengis.net/def/function/geosparql/\";\r\n    rdfs=\"http://www.w3.org/2000/01/rdf-schema#\";\r\n    uom=\"http://www.opengis.net/def/uom/OGC/1.0/\";\r\n    sf=\"http://www.opengis.net/ont/sf#\";\r\n    xsd=\"http://www.w3.org/2001/XMLSchema#\";\r\n    geor=\"http://www.opengis.net/def/rule/geosparql/\";\r\n    namespaces = {\t\"rdf\" : rdf,\r\n                \t\"owl\" : owl,\r\n                \t\"ogc\" : ogc,\r\n                \t\"my\" : my,\r\n                \t\"gml\" : gml,\r\n                \t\"geo\" : geo,\r\n                \t\"geof\": geof,\r\n                \t\"rdfs\": rdfs,\r\n                \t\"uom\": uom,\r\n                \t\"sf\": sf,\r\n                \t\"xsd\": xsd,\r\n                \t\"geor\": geor\r\n            }\r\n    inserts = WKT_res\r\n    \r\n    # open RDF header\r\n    rdfStr = \"<rdf:RDF\";\r\n    \r\n    # handle Namespaces\r\n    for key in namespaces:\r\n        rdfStr += \" xmlns:\" + key + \"='\" + namespaces[key] + \"'\";\r\n    \r\n    rdfStr += \">\";\r\n    \r\n    #add inserts\r\n    \r\n    rdfStr += \"<rdf:Description rdf:about='my:\" + \"RootModel\" + \"'>\";\r\n    \r\n    for insert in inserts:\r\n        rdfStr += insert;\r\n    \r\n    rdfStr += \"</rdf:Description>\"\r\n    \r\n    # close RDF header\r\n    rdfStr += \"</rdf:RDF>\"\r\n    \r\n    # Weisen Sie Ihre Ausgabe der OUT-Variablen zu.\r\n    return rdfStr\r\n\r\n############## Ground Truth Generator ###############\r\ndef getGeometry(geo_obj):\r\n    return geo_obj[3]\r\n\r\ndef getGeoType(geo_obj):\r\n    return geo_obj[2]\r\n    \r\ndef getGeoName(geo_obj):\r\n    return geo_obj[1]\r\n    \r\ndef ground_truth_generator(geometry_lst):\r\n    geo_lst = geometry_lst\r\n    inter_geo_dict = {}\r\n    for i in range(0, len(geo_lst)-1):\r\n        geo_obj_1 = geo_lst[i]\r\n        geometry_1 = getGeometry(geo_obj_1)\r\n    \r\n        geo_obj_1_has_intersection = False\r\n        for j in range(1, len(geo_lst)):\r\n            geo_obj_2 = geo_lst[j]\r\n            geometry_2 = getGeometry(geo_obj_2)\r\n            \r\n            if getGeoName(geo_obj_1) != getGeoName(geo_obj_2):\r\n                temp_bool = False\r\n                try:\r\n                    temp_bool = Geometry.DoesIntersect(geometry_1, geometry_2)\r\n                except Exception as err:\r\n                    print(f\"Unexpected {err=}, {type(err)=}\")\r\n                if temp_bool:\r\n                    geo_obj_1_has_intersection = True\r\n                    inter_geo_dict[getGeoName(geo_obj_2)] = getGeoType(geo_obj_2)\r\n                    \r\n        if geo_obj_1_has_intersection:\r\n            inter_geo_dict[getGeoName(geo_obj_1)] = getGeoType(geo_obj_1)    \r\n    #================= Output ====================\r\n    if inter_geo_dict is None:\r\n        inter_geo_dict = {}\r\n    return inter_geo_dict\r\n    \r\n############## RDF 2 JSON ###############\r\ndef rdfParsing2GeoData(str):\r\n    \"\"\" it returns the json file in structure like { \"POLYGON1\" : [...], \r\n                                                     \"POLYGON2\" : [...], \r\n                                                     \"MULTIPOLYGON1\" : [...], ...\r\n                                                    }\r\n    \"\"\"\r\n    #dom = parse(path)\r\n    #tree = ET.ElementTree(ET.fromstring(str))\r\n    geo_dict = {}\r\n    tree = io.StringIO(str)\r\n    dom = parse(tree)\r\n    data = dom.documentElement\r\n    rdf_desc_lst = data.getElementsByTagName(\"rdf:Description\")\r\n    # geo_in_wkt = data.getElementsByTagName(\"geo:asWKT\")\r\n\r\n    for i in range(1, len(rdf_desc_lst)): # first description element (root element) should be removed.\r\n        descr_el = rdf_desc_lst[i]\r\n        geo_name_num = descr_el.attributes._attrs['rdf:about'].nodeValue.split('#')[1]\r\n        geo_wkt_data = \"\"\r\n        try:\r\n            geo_wkt_data = descr_el.childNodes[0].firstChild.data\r\n        except:\r\n            geo_wkt_data = descr_el.childNodes[1].firstChild.data\r\n        geo_algebra_lst = []\r\n\r\n        if ( geo_name_num.find('POINT') != -1 or\r\n            geo_name_num.find('Point') != -1 ):\r\n            \r\n            wkt_data_lst = geo_wkt_data.split(\"(\")[1] # remove title 'POINT'\r\n            vert_str_lst = wkt_data_lst\r\n            vert_str_lst = vert_str_lst.replace( \")\", \"\" ) # remove character ')'\r\n\r\n            pt_algebra_lst = []\r\n            pt_str_lst = vert_str_lst.split(\" \")\r\n\r\n            pt_algebra_lst = [ float(pt_str) for pt_str in pt_str_lst ]\r\n            geo_algebra_lst.append(pt_algebra_lst)\r\n            \r\n        if ( geo_name_num.find('LINESTRING') != -1 or\r\n            geo_name_num.find('Linestring') != -1 or\r\n            geo_name_num.find('LINE') != -1 or\r\n            geo_name_num.find('Line') != -1 ):\r\n\r\n            wkt_data_lst = geo_wkt_data.split(\"((\")[1] # remove title 'LINESTRING'\r\n            vert_str_lst = wkt_data_lst\r\n            vert_str_lst = vert_str_lst.replace( \")\", \"\" ) # remove character ')'\r\n            vert_str_lst = vert_str_lst.split(\", \")\r\n\r\n            line_algebra_lst = []\r\n            for i in range(0, len(vert_str_lst)):\r\n\r\n                pt_str_lst = vert_str_lst[i].split(\" \")\r\n                line_algebra_lst.append([ float(pt_str) for pt_str in pt_str_lst ])\r\n            geo_algebra_lst.append(line_algebra_lst)\r\n\r\n        if ( geo_name_num.find('POLYGON') != -1 or \r\n            geo_name_num.find('Polygon') != -1 ):\r\n\r\n            wkt_data_lst = geo_wkt_data.split(\"((\")[1] # remove title 'POLYGON Z'\r\n            vert_str_lst = wkt_data_lst\r\n            vert_str_lst = vert_str_lst.replace( \")\", \"\" ) # remove character ')'\r\n            vert_str_lst = vert_str_lst.replace( \"(\", \"\" ) # remove character '('\r\n            vert_str_lst = vert_str_lst.split(\", \")\r\n\r\n            face_algebra_lst = []\r\n            for i in range(0, len(vert_str_lst)-1): # last point not included\r\n\r\n                pt_str_lst = vert_str_lst[i].split(\" \")\r\n                face_algebra_lst.append([ float(pt_str) for pt_str in pt_str_lst ])\r\n            geo_algebra_lst.append(face_algebra_lst)\r\n\r\n        if ( geo_name_num.find('MULTIPOLYGON') != -1 or\r\n            geo_name_num.find('Multipolygon') != -1  or\r\n            geo_name_num.find('CUBE') != -1 or\r\n            geo_name_num.find('Cube') != -1 or\r\n            geo_name_num.find('SPHERE') != -1 or\r\n            geo_name_num.find('Sphere') != -1 ):\r\n\r\n            wkt_data_lst = geo_wkt_data.split(\"(((\")[1] # remove title 'MULTIPOLYGON Z'\r\n            face_str_lst = wkt_data_lst.split(\"), \")\r\n\r\n            face_algebra_lst = []\r\n            for face_str in face_str_lst:\r\n                vert_str_lst = face_str.replace( \")\", \"\" ) # remove character ')'\r\n                vert_str_lst = vert_str_lst.replace( \"(\", \"\" ) # remove character '('\r\n                vert_str_lst = vert_str_lst.split(\", \")\r\n\r\n                pt_algebra_lst = []\r\n                for i in range(0, len(vert_str_lst)-1): # last point not included\r\n\r\n                    pt_str_lst = vert_str_lst[i].split(\" \")\r\n                        \r\n                    pt_algebra = [ float(pt_str) for pt_str in pt_str_lst ]\r\n                    pt_algebra_lst.append(pt_algebra)\r\n\r\n                face_algebra_lst.append(pt_algebra_lst)\r\n            geo_algebra_lst = face_algebra_lst\r\n\r\n        if geo_name_num not in geo_dict.keys():\r\n            geo_dict[geo_name_num] = geo_algebra_lst\r\n    return geo_dict\r\n    \r\n######################################################\r\n############## RDF File Configuration ###############\r\nrdf_case_study_file_path = \"C:\\\\Users\\\\yhe\\\\Documents\\\\Developer\\\\Repo\\\\ExtendingJena\\\\src\\\\main\\\\resources\\\\rdf\\\\case_study\\\\\"\r\nrdf_file_contents = \"\"\r\n\r\n############## JSON File Configuration ###############\r\njson_case_study_file_path = \"C:\\\\Users\\\\yhe\\\\Documents\\\\Developer\\\\Repo\\\\ExtendingJena\\\\src\\\\main\\\\resources\\\\JSON\\\\case_study\\\\\"\r\njson_ground_truth_file_path = \"C:\\\\Users\\\\yhe\\\\Documents\\\\Developer\\\\Repo\\\\ExtendingJena\\\\src\\\\main\\\\resources\\\\JSON\\\\ground_truth\\\\\"\r\njson_file_contents = {\"test\":\"\"}\r\n\r\n########## JSON Export #############\r\ndef JSON_export(json_file_path, json_file_name, json_file_index, json_file_contents):\r\n    \r\n    tmp_json_file_name = json_file_index + json_file_name\r\n    tmp_json_file_path = json_file_path + tmp_json_file_name\r\n    try:\r\n        with open(tmp_json_file_path, \"w\") as f:\r\n            json.dump(json_file_contents, f, sort_keys=True, indent=4)\r\n            #f.write(json_file_contents)\r\n    except FileExistsError:\r\n        print(f\"File '{json_file_path}' already exists.\")\r\n\r\n########## RDF Export #############\r\ndef rdf_export(rdf_file_path, rdf_file_name, rdf_file_index, rdf_file_contents):\r\n\r\n    tmp_rdf_file_name = rdf_file_index + rdf_file_name\r\n    tmp_rdf_file_path = rdf_file_path + tmp_rdf_file_name\r\n    try:\r\n        with open(tmp_rdf_file_path, \"w\") as f:\r\n            f.write(rdf_file_contents)\r\n    except FileExistsError:\r\n        print(f\"File '{rdf_file_path}' already exists.\")\r\n        \r\n        \r\n############## Contents (RDF, JSON) Generation ###############\r\nfor i in range(1, IN[0]+1):\r\n    # create geometries randomly\r\n    tmp_geo_lst = random_geo_generator(i)\r\n    # create ground truth values and store it locally\r\n    inter_geo_dict = ground_truth_generator(tmp_geo_lst)\r\n    JSON_export(json_ground_truth_file_path, \"groundTruth.json\", str(i), inter_geo_dict)\r\n    # convert geos to WKT\r\n    wkt_res = wkt_Converter(tmp_geo_lst)\r\n    # wrapp WKT with RDF labels\r\n    rdf_contents = RDF_Wrapper(wkt_res)\r\n    # store RDF file locally\r\n    rdf_export(rdf_case_study_file_path, \"caseStudy.rdf\", str(i), rdf_contents)\r\n    # convert RDF file to JSON file and store it locally\r\n    rdf_2_json_contents = rdfParsing2GeoData(rdf_contents)\r\n    JSON_export(json_case_study_file_path, \"caseStudy.json\", str(i), rdf_2_json_contents)\r\n    \r\n\"\"\"    \r\n# RDF for-loops\r\nfor i in range(1, 10):\r\n    rdf_file_contents += str(i)\r\n    index = str(i)\r\n    rdf_export(rdf_file_path, rdf_file_name, index, rdf_file_contents)\r\n# JSON for-loops\r\nfor j in range(1, 10):\r\n    json_file_contents[\"test\"]=str(j)\r\n    index = str(j)\r\n    JSON_export(json_file_path, json_file_name, index, json_file_contents)\r\n\"\"\"\r\n#====================================\r\nOUT = 0",
      "Engine": "CPython3",
      "VariableInputPorts": true,
      "Id": "8b44f3a42c6a4f5ebe63f1bf10dbcbfc",
      "Inputs": [
        {
          "Id": "cf9af66fc47048c88cbab42f57c3e6fc",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "0d4b46d2ba1f47159165c57dfc3d31b6",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded Python script."
    },
    {
      "ConcreteType": "Dynamo.Graph.Nodes.CodeBlockNodeModel, DynamoCore",
      "NodeType": "CodeBlockNode",
      "Code": "num_file = 5;",
      "Id": "a3527ba242af45d9b678bc458df157c4",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "d7b9bbc6c3c34ffba6abb5286c92588b",
          "Name": "",
          "Description": "num_file",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Allows for DesignScript code to be authored directly"
    }
  ],
  "Connectors": [
    {
      "Start": "d7b9bbc6c3c34ffba6abb5286c92588b",
      "End": "cf9af66fc47048c88cbab42f57c3e6fc",
      "Id": "1e95841cfaec4adba8470a8e64f245c5"
    }
  ],
  "Dependencies": [],
  "NodeLibraryDependencies": [],
  "Bindings": [],
  "View": {
    "Dynamo": {
      "ScaleFactor": 1.0,
      "HasRunWithoutCrash": true,
      "IsVisibleInDynamoLibrary": true,
      "Version": "2.8.0.2471",
      "RunType": "Manual",
      "RunPeriod": "1000"
    },
    "Camera": {
      "Name": "Background Preview",
      "EyeX": -17.0,
      "EyeY": 24.0,
      "EyeZ": 50.0,
      "LookX": 12.0,
      "LookY": -13.0,
      "LookZ": -58.0,
      "UpX": 0.0,
      "UpY": 1.0,
      "UpZ": 0.0
    },
    "NodeViews": [
      {
        "ShowGeometry": true,
        "Name": "AllinOneGenerator",
        "Id": "8b44f3a42c6a4f5ebe63f1bf10dbcbfc",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 365.27448071216611,
        "Y": 287.12166172106822
      },
      {
        "ShowGeometry": true,
        "Name": "Code Block",
        "Id": "a3527ba242af45d9b678bc458df157c4",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 72.623145400593444,
        "Y": 278.21068249258155
      }
    ],
    "Annotations": [],
    "X": 47.486249999999984,
    "Y": 54.81,
    "Zoom": 0.8425
  }
}